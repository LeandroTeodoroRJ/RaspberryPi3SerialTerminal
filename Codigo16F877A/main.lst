CCS PCM C Compiler, Version 4.104, 5967               21-jul-17 19:18

               Filename: C:\DADOS\projeto\RaspberryPi3PortaSerial\Codigo16F877A\main.lst

               ROM used: 710 words (9%)
                         Largest free fragment is 2048
               RAM used: 12 (3%) at main() level
                         30 (8%) worst case
               Stack:    7 worst case (5 in main + 2 for interrupts)

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   275
0003:  NOP
.................... //**************************************************************************** 
.................... //                        RASPBERRY TERMINAL PIC 
.................... //**************************************************************************** 
.................... //Compilador CCS PCWH Ver 4.104 
....................  
.................... #include <16F877.h>               
.................... //////// Standard Header file for the PIC16F877 device //////////////// 
.................... #device PIC16F877 
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
027E:  BCF    03.5
027F:  CLRF   20
0280:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <16f8x_registradores.h>//MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //********************************************************** 
.................... //INCLUDE DE MAPEAMENTO DE MEÓRIA DOS REGISTRADORES 
.................... //ESPECIAIS E BITS DOS MESMOS PARA OS mC 16f87X 
.................... //********************************************************** 
....................  
.................... #byte option_reg = 0x81 
.................... #byte status = 0x03 
.................... #byte tris_a = 0x85        //#byte - define o endereco do 
.................... #byte tris_b = 0x86        //registrador no banco de memoria 
.................... #byte tris_c = 0x87        //de acordo com o datasheet 
.................... #byte port_a = 0x05 
.................... #byte port_b = 0x06 
.................... #byte port_c = 0x07 
.................... #byte port_d = 0x08 
.................... #byte tris_d = 0x88 
.................... #byte intcon = 0x0b 
....................  
.................... //USART 
.................... #byte txsta = 0x98 
.................... #byte rcsta = 0x18 
.................... #byte spbrg = 0x99 
.................... #byte txreg = 0x19 
.................... #byte rcreg = 0x1a    
....................  
.................... #byte pir1 = 0x0c 
.................... #byte pie1 = 0x8c 
....................  
.................... //registrador pie1 
.................... #bit  eeie   = pie1.7 
.................... #bit  cmie   = pie1.6 
.................... #bit  rcie   = pie1.5 
.................... #bit  txie   = pie1.4 
.................... #bit  ccp1ie = pie1.2 
.................... #bit  tmr2ie = pie1.1 
.................... #bit  tmr1ie = pie1.0 
....................  
.................... //registrador pir1 
.................... #bit  eeif   = pir1.7 
.................... #bit  cmif   = pir1.6 
.................... #bit  rcif   = pir1.5 
.................... #bit  txif   = pir1.4 
.................... #bit  ccp1if = pir1.2 
.................... #bit  tmr2if = pir1.1 
.................... #bit  tmr1if = pir1.0 
....................  
.................... //registrador txsta 
.................... #bit  csrc  = txsta.7 
.................... #bit  tx9   = txsta.6 
.................... #bit  txen  = txsta.5 
.................... #bit  sync  = txsta.4 
.................... #bit  brgh =  txsta.2 
.................... #bit  trmt =  txsta.1 
.................... #bit  tx9d =  txsta.0 
....................  
.................... //registrador rcsta 
.................... #bit  spen  = rcsta.7 
.................... #bit  rx9   = rcsta.6 
.................... #bit  sren  = rcsta.5 
.................... #bit  cren  = rcsta.4 
.................... #bit  adden = rcsta.3 
.................... #bit  ferr  = rcsta.2 
.................... #bit  oerr  = rcsta.1 
.................... #bit  rx9d  = rcsta.0 
....................  
....................  
.................... //registrador intcon 
.................... #bit  gie = 0x0b.7 
.................... #bit  peie = 0x0b.6 
.................... #bit  t0ie = 0x0b.5 
.................... #bit  inte = 0x0b.4 
.................... #bit  rbie = 0x0b.3 
.................... #bit  t0if = 0x0b.2 
.................... #bit  intf = 0x0b.1 
.................... #bit  rbif = 0x0b.0 
....................  
.................... #bit  trigger = port_b.3 
.................... #bit  trigger_inv =  port_b.4 
....................  
....................                                                      
....................  
.................... //**************************************************************************** 
.................... //                    CONFIGURAÇÕES DO COMPILADOR 
.................... //**************************************************************************** 
....................  
.................... #use fast_io(a)                  //modo de entrada e saida de dados que 
.................... #use fast_io(b)                  //o compilador nao configura o tris 
....................  
.................... #use delay(clock=4000000)        //clock usual 
*
009C:  MOVLW  2C
009D:  MOVWF  04
009E:  BCF    03.7
009F:  MOVF   00,W
00A0:  BTFSC  03.2
00A1:  GOTO   0B0
00A2:  MOVLW  01
00A3:  MOVWF  78
00A4:  CLRF   77
00A5:  DECFSZ 77,F
00A6:  GOTO   0A5
00A7:  DECFSZ 78,F
00A8:  GOTO   0A4
00A9:  MOVLW  4A
00AA:  MOVWF  77
00AB:  DECFSZ 77,F
00AC:  GOTO   0AB
00AD:  GOTO   0AE
00AE:  DECFSZ 00,F
00AF:  GOTO   0A2
00B0:  RETURN
.................... #fuses HS,NOLVP,NOWDT,PUT,NOPROTECT // 
....................  
.................... //#rom 0x2100={0b00010010,0x00}    //programa os primeiros dois endereços da eeprom 
....................                                   
....................  
.................... //**************************************************************************** 
.................... //                                BIOS 
.................... //**************************************************************************** 
.................... //****************************  ENTRADAS  ************************************ 
....................  
.................... //*****************************  SAÍDAS  ************************************* 
.................... // As definições a seguir são utilizadas para acesso aos pinos do display 
.................... // caso o pino RW não seja utilizado, comente a definição lcd_rw 
.................... #ifndef lcd_enable 
....................    #define lcd_enable       pin_d5      // pino enable do LCD 
....................    #define lcd_rs         pin_d4      // pino rs do LCD 
....................    //#define lcd_rw      pin_e2      // pino rw do LCD 
....................    #define lcd_d4         pin_d0      // pino de dados d4 do LCD 
....................    #define lcd_d5         pin_d1      // pino de dados d5 do LCD 
....................    #define lcd_d6         pin_d2      // pino de dados d6 do LCD 
....................    #define lcd_d7         pin_d3      // pino de dados d7 do LCD 
.................... #endif 
.................... //**************************************************************************** 
.................... //                        CONSTANTES E VARIÁVEIS 
.................... //**************************************************************************** 
.................... #define  debouce     10 
.................... #define alarme_off_flag alarme_status,1 
....................  
.................... int   w_temp; 
.................... int   status_temp; 
.................... short int   dado_recebido;    //flag de novo dado recebido 
.................... int   count; 
....................  
....................  
.................... //*************************************************************************** 
.................... //                               DRIVES 
.................... //*************************************************************************** 
.................... #include "C:\DADOS\projeto\INCLUDES\usart.h" 
.................... //************************************************************************ 
.................... //             DRIVE PARA O HARDWARE DA USART INTERNA 
.................... //                            ATZ:23.09.11 
.................... //                           AUTOR: LEANDRO 
.................... //************************************************************************ 
....................  
.................... //************************************************************************ 
.................... //                      CONFIGURA O BAUD RATE 
.................... //************************************************************************ 
.................... //Vide: PIC Técnicas Avançacas pág.321 
.................... //EXEMPLO DE CHAMADA: usart_baud_rate(high_speed, 25); 
....................  
.................... #define high_speed  1 
.................... #define low_speed   0 
....................  
.................... usart_baud_rate(short int vel, int baud_rate){ 
.................... brgh=vel; 
*
0077:  BSF    03.5
0078:  BCF    18.2
0079:  BCF    03.5
007A:  BTFSS  27.0
007B:  GOTO   07F
007C:  BSF    03.5
007D:  BSF    18.2
007E:  BCF    03.5
.................... spbrg=baud_rate; 
007F:  MOVF   28,W
0080:  BSF    03.5
0081:  MOVWF  19
.................... } 
0082:  BCF    03.5
0083:  BCF    0A.3
0084:  BCF    0A.4
0085:  GOTO   29C (RETURN)
....................  
.................... //************************************************************************ 
.................... //                   CONFIGURA INTERRUPÇÃO DA USART 
.................... //************************************************************************ 
.................... //PARA ATIVAÇÃO DA INTERRUPÇÃO NECESSITA DA ATIVAÇÃO DO BIT INTCON -> GIE=1 
.................... //EXEMPLO DE CHAMADA: usart_int(tx_int_off, rx_int_off, int_9bit_off); 
.................... //O BIT ADDEN HABILITA A INTERRUPÇÃO PELO RECEBIMENTO DO 9ºBIT 
....................  
....................  
.................... #define tx_int_on 1 
.................... #define tx_int_off 0 
.................... #define rx_int_on 1 
.................... #define rx_int_off 0 
.................... #define int_9bit_on 1 
.................... #define int_9bit_off 0 
....................  
.................... usart_int(short int tx_int, short int rx_int, short int int_9bit){ 
.................... rcie=rx_int; 
0086:  BSF    03.5
0087:  BCF    0C.5
0088:  BCF    03.5
0089:  BTFSS  28.0
008A:  GOTO   08E
008B:  BSF    03.5
008C:  BSF    0C.5
008D:  BCF    03.5
.................... txie=tx_int; 
008E:  BSF    03.5
008F:  BCF    0C.4
0090:  BCF    03.5
0091:  BTFSS  27.0
0092:  GOTO   096
0093:  BSF    03.5
0094:  BSF    0C.4
0095:  BCF    03.5
.................... adden=int_9bit; 
0096:  BCF    18.3
0097:  BTFSC  29.0
0098:  BSF    18.3
.................... } 
0099:  BCF    0A.3
009A:  BCF    0A.4
009B:  GOTO   2B8 (RETURN)
....................  
....................  
.................... //************************************************************************* 
.................... //                        CONFIGURA A USART 
.................... //************************************************************************* 
.................... //OBS.: Detecção de endereços (9bit) somente disponível no modo assincrono 
.................... //EXEMPLO DE CHAMADA DE FUNÇÃO 
.................... //usart_config(modo8bits, assincrono, tx_on, usart_on, rx_continuo); 
....................  
....................  
.................... #define modo8bits  0 
.................... #define modo9bits  1  //habilita recepção de endereço 
.................... #define tx_on  1  //tx habilitado 
.................... #define tx_off 0 
.................... #define sincrono 1 
.................... #define assincrono 0 
.................... #define usart_on  1 
.................... #define usart_off 0 
.................... #define rx_continuo  1 
.................... #define rx_unica     0 
....................  
....................  
.................... usart_config(short int bits, short int syc, short int tx_liga, 
.................... short int usart_liga, short int rx_config){ 
.................... tx9=bits; 
*
004B:  BSF    03.5
004C:  BCF    18.6
004D:  BCF    03.5
004E:  BTFSS  34.0
004F:  GOTO   053
0050:  BSF    03.5
0051:  BSF    18.6
0052:  BCF    03.5
.................... rx9=bits; 
0053:  BCF    18.6
0054:  BTFSC  34.0
0055:  BSF    18.6
.................... txen=tx_liga; 
0056:  BSF    03.5
0057:  BCF    18.5
0058:  BCF    03.5
0059:  BTFSS  36.0
005A:  GOTO   05E
005B:  BSF    03.5
005C:  BSF    18.5
005D:  BCF    03.5
.................... sync=syc; 
005E:  BSF    03.5
005F:  BCF    18.4
0060:  BCF    03.5
0061:  BTFSS  35.0
0062:  GOTO   066
0063:  BSF    03.5
0064:  BSF    18.4
0065:  BCF    03.5
.................... spen=usart_liga; 
0066:  BCF    18.7
0067:  BTFSC  37.0
0068:  BSF    18.7
.................... cren=rx_config; 
0069:  BCF    18.4
006A:  BTFSC  38.0
006B:  BSF    18.4
.................... ferr=0; 
006C:  BCF    18.2
.................... oerr=0; 
006D:  BCF    18.1
.................... } 
006E:  RETURN
....................  
.................... //*************************************************************************** 
.................... //             TRANSMITE UM BYTE PELA USART (MODO 8 BITS) 
.................... //*************************************************************************** 
.................... usart_tx(int dado){ 
.................... txreg=dado; 
*
0188:  MOVF   27,W
0189:  MOVWF  19
.................... } 
....................  
.................... //*************************************************************************** 
.................... //             RECEBE UM BYTE PELA USART (MODO 8 BITS) 
.................... //*************************************************************************** 
.................... //A FUNÇÃO RETORNA: 
.................... //    0 SE A USART NÃO RECEBEU UM NOVO DADO 
.................... //    1 SE A USART RECEBEU UM NOVO DADO E CARREGA EM usart_rx_dado 
.................... //    2 PARA ERRO DE FRAME 
.................... //    3 PARA ERRO DE OVERRUN (BUFFER OVERLOAD) 
....................  
.................... #define  novo_dado   0x01 
.................... int usart_rx_dado; 
....................  
.................... int usart_rx(){ 
....................    if (ferr==1){ 
*
0012:  BTFSS  18.2
0013:  GOTO   018
....................    return (0x02); //erro de frame (stop bit não recebido ou fora de hora) 
0014:  MOVLW  02
0015:  MOVWF  78
0016:  GOTO   02A
....................    ferr=0; 
0017:  BCF    18.2
....................    } 
....................    if (oerr==1){ 
0018:  BTFSS  18.1
0019:  GOTO   01E
....................    return (0x03); //erro de overrun (três caracteres foram recebidos pela usart sem ser lidos pela CPU) 
001A:  MOVLW  03
001B:  MOVWF  78
001C:  GOTO   02A
....................    oerr=0; 
001D:  BCF    18.1
....................    } 
....................    if (rcif==0) return (0x00); 
001E:  BTFSC  0C.5
001F:  GOTO   023
0020:  MOVLW  00
0021:  MOVWF  78
0022:  GOTO   02A
....................    if (rcif==1){ 
0023:  BTFSS  0C.5
0024:  GOTO   02A
....................    usart_rx_dado=rcreg; 
0025:  MOVF   1A,W
0026:  MOVWF  26
....................    return (0x01); 
0027:  MOVLW  01
0028:  MOVWF  78
0029:  GOTO   02A
....................    } 
.................... } 
....................  
.................... //*************************************************************************** 
.................... //          TRANSMITE UM BYTE PELA USART (MODO 9 BITS) 
.................... //*************************************************************************** 
.................... //EXEMPLO DE CHAMADA: 
.................... //usart_tx_9bit(adress, 0x0F); 
.................... //usart_tx_9bit(data, 0x0c); 
....................  
.................... #define adress 1 
.................... #define data 0 
....................  
.................... usart_tx_9bit(short int bit_adress, int dado){ 
.................... tx9d=bit_adress; 
.................... txreg=dado; 
.................... } 
....................  
.................... //*************************************************************************** 
.................... //             RECEBE UM BYTE PELA USART (MODO 9 BITS) 
.................... //*************************************************************************** 
.................... //A FUNÇÃO RETORNA: 
.................... //    0 SE A USART NÃO RECEBEU UM NOVO DADO 
.................... //    1 SE A USART RECEBEU UM NOVO ENDEREÇO E CARREGA EM usart_rx_dado 
.................... //    2 SE A USART RECEBEU UM NOVO DADO E CARREGA EM usart_rx_dado 
.................... //    3 PARA ERRO DE FRAME 
.................... //    4 PARA ERRO DE OVERRUN (BUFFER OVERLOAD) 
....................  
.................... int usart_rx_9bit(){ 
....................    if (rcif==1){ 
....................    usart_rx_dado=rcreg; 
....................    } 
....................    if (ferr==1){ 
....................    return (0x03); //erro de frame (stop bit não recebido ou fora de hora) 
....................    ferr=0; 
....................    } 
....................    if (oerr==1){ 
....................    return (0x04); //erro de overrun (três caracteres foram recebidos pela usart sem ser lidos pela CPU) 
....................    oerr=0; 
....................    } 
....................    if ((rcif==1)&(rx9d==1)) return (0x01); //recebido um endereço 
....................    if (rcif==1) return (0x02); 
....................  
.................... } 
....................  
.................... //************************************************************************** 
.................... //                      DETECÇÃO DE INTERRUPÇÃO 
.................... //************************************************************************** 
.................... short int interrupt_rx_usart(){ 
....................    return(rcif); 
*
000C:  MOVLW  00
000D:  BTFSC  0C.5
000E:  MOVLW  01
000F:  MOVWF  78
.................... } 
....................  
.................... //*************************************************************************** 
.................... //                            FIM DO INCLUDE 
.................... //*************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "c:\dados\projeto\includes\lcd.h" 
....................  
.................... /************************************************************************ 
....................         MOD_LCD.C - Biblioteca de manipulação de módulo LCD 
....................                         Autor: Fábio Pereira                                                 
....................  
.................... FUNÇÕES: 
....................          void lcd_ini(void) ->  rotina de inicialização do display 
....................          void lcd_pos_xy( byte x, byte y) -> posiciona o cursor  
....................          void lcd_escreve( char c) ->  envia caractere para o display ou 
....................                                        uma string ex. lcd_escreve("R.Johnson"); 
....................                                        argumentos ex. lcd_escreve('\f'); 
....................                                        \f -> apaga o display e retorna a primeira posição da primeira linha 
....................                                        \r -> passa para linha de baixo "enter"    
....................                                        \n -> sem uso   
.................... ATUALIZADO: 14.08.10                                               
.................... /************************************************************************/ 
....................  
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 linhas 
.................... #define lcd_seg_lin 0x40    // Endereço da segunda linha na RAM do LCD 
....................  
.................... // a constante abaixo define a seqüência de inicialização do módulo LCD 
.................... byte CONST INI_LCD[4] = {0x20 | (lcd_type << 2), 0xf, 1, 6}; 
....................  
.................... /* FUNÇÃO DESABILITADA DEVIDO AO DESUSO 
....................  
.................... byte lcd_le_byte() 
.................... // lê um byte do LCD (somente com pino RW) 
.................... { 
....................    byte dado; 
....................    // configura os pinos de dados como entradas 
....................    input(lcd_d4); 
....................    input(lcd_d5); 
....................    input(lcd_d6); 
....................    input(lcd_d7); 
....................    // se o pino rw for utilizado, coloca em 1 
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_high(lcd_enable); // habilita display 
....................    dado = 0;   // zera a variável de leitura 
....................    // lê os quatro bits mais significativos 
....................    if (input(lcd_d7)) bit_set(dado,7); 
....................    if (input(lcd_d6)) bit_set(dado,6); 
....................    if (input(lcd_d5)) bit_set(dado,5); 
....................    if (input(lcd_d4)) bit_set(dado,4); 
....................    // dá um pulso na linha enable 
....................    output_low(lcd_enable); 
....................    output_high(lcd_enable); 
....................    // lê os quatro bits menos significativos 
....................    if (input(lcd_d7)) bit_set(dado,3); 
....................    if (input(lcd_d6)) bit_set(dado,2); 
....................    if (input(lcd_d5)) bit_set(dado,1); 
....................    if (input(lcd_d4)) bit_set(dado,0); 
....................    output_low(lcd_enable);   // desabilita o display 
....................    return dado;   // retorna o byte lido 
.................... } 
.................... */ 
....................  
....................  
.................... void lcd_envia_nibble( byte dado ) 
.................... // envia um dado de quatro bits para o display 
.................... { 
....................    // coloca os quatro bits nas saidas 
....................    output_bit(lcd_d4,bit_test(dado,0)); 
*
00B1:  BTFSC  33.0
00B2:  GOTO   0B5
00B3:  BCF    08.0
00B4:  GOTO   0B6
00B5:  BSF    08.0
00B6:  BSF    03.5
00B7:  BCF    08.0
....................    output_bit(lcd_d5,bit_test(dado,1)); 
00B8:  BCF    03.5
00B9:  BTFSC  33.1
00BA:  GOTO   0BD
00BB:  BCF    08.1
00BC:  GOTO   0BE
00BD:  BSF    08.1
00BE:  BSF    03.5
00BF:  BCF    08.1
....................    output_bit(lcd_d6,bit_test(dado,2)); 
00C0:  BCF    03.5
00C1:  BTFSC  33.2
00C2:  GOTO   0C5
00C3:  BCF    08.2
00C4:  GOTO   0C6
00C5:  BSF    08.2
00C6:  BSF    03.5
00C7:  BCF    08.2
....................    output_bit(lcd_d7,bit_test(dado,3)); 
00C8:  BCF    03.5
00C9:  BTFSC  33.3
00CA:  GOTO   0CD
00CB:  BCF    08.3
00CC:  GOTO   0CE
00CD:  BSF    08.3
00CE:  BSF    03.5
00CF:  BCF    08.3
....................    // dá um pulso na linha enable 
....................    output_high(lcd_enable); 
00D0:  BCF    08.5
00D1:  BCF    03.5
00D2:  BSF    08.5
....................    output_low(lcd_enable); 
00D3:  BSF    03.5
00D4:  BCF    08.5
00D5:  BCF    03.5
00D6:  BCF    08.5
.................... } 
00D7:  RETURN
....................  
....................  
.................... void lcd_envia_byte( boolean endereco, byte dado ) 
.................... { 
....................    // coloca a linha rs em 0 
....................    output_low(lcd_rs); 
00D8:  BSF    03.5
00D9:  BCF    08.4
00DA:  BCF    03.5
00DB:  BCF    08.4
....................    // aguarda o display ficar desocupado 
....................    //while ( bit_test(lcd_le_byte(),7) ) ; 
....................    // configura a linha rs dependendo do modo selecionado 
....................    output_bit(lcd_rs,endereco); 
00DC:  MOVF   30,F
00DD:  BTFSS  03.2
00DE:  GOTO   0E1
00DF:  BCF    08.4
00E0:  GOTO   0E2
00E1:  BSF    08.4
00E2:  BSF    03.5
00E3:  BCF    08.4
....................    delay_us(100);   // aguarda 100 us 
00E4:  MOVLW  21
00E5:  MOVWF  77
00E6:  DECFSZ 77,F
00E7:  GOTO   0E6
....................    // caso a linha rw esteja definida, coloca em 0 
....................    #ifdef lcd_rw 
....................       output_low(lcd_rw); 
....................    #endif 
....................    // desativa linha enable 
....................    output_low(lcd_enable); 
00E8:  BCF    08.5
00E9:  BCF    03.5
00EA:  BCF    08.5
....................    // envia a primeira parte do byte 
....................    lcd_envia_nibble(dado >> 4); 
00EB:  SWAPF  31,W
00EC:  MOVWF  32
00ED:  MOVLW  0F
00EE:  ANDWF  32,F
00EF:  MOVF   32,W
00F0:  MOVWF  33
00F1:  CALL   0B1
....................    // envia a segunda parte do byte 
....................    lcd_envia_nibble(dado & 0x0f); 
00F2:  MOVF   31,W
00F3:  ANDLW  0F
00F4:  MOVWF  32
00F5:  MOVWF  33
00F6:  CALL   0B1
.................... } 
00F7:  RETURN
....................  
....................  
.................... void lcd_ini() 
.................... // rotina de inicialização do display 
.................... { 
....................    byte conta; 
....................    output_low(lcd_d4); 
00F8:  BSF    03.5
00F9:  BCF    08.0
00FA:  BCF    03.5
00FB:  BCF    08.0
....................    output_low(lcd_d5); 
00FC:  BSF    03.5
00FD:  BCF    08.1
00FE:  BCF    03.5
00FF:  BCF    08.1
....................    output_low(lcd_d6); 
0100:  BSF    03.5
0101:  BCF    08.2
0102:  BCF    03.5
0103:  BCF    08.2
....................    output_low(lcd_d7); 
0104:  BSF    03.5
0105:  BCF    08.3
0106:  BCF    03.5
0107:  BCF    08.3
....................    output_low(lcd_rs); 
0108:  BSF    03.5
0109:  BCF    08.4
010A:  BCF    03.5
010B:  BCF    08.4
....................    #ifdef lcd_rw 
....................       output_high(lcd_rw); 
....................    #endif 
....................    output_low(lcd_enable); 
010C:  BSF    03.5
010D:  BCF    08.5
010E:  BCF    03.5
010F:  BCF    08.5
....................    delay_ms(15); 
0110:  MOVLW  0F
0111:  MOVWF  2C
0112:  CALL   09C
....................    // envia uma seqüência de 3 vezes 0x03 
....................    // e depois 0x02 para configurar o módulo 
....................    // para modo de 4 bits 
....................    for(conta=1;conta<=3;++conta) 
0113:  MOVLW  01
0114:  MOVWF  27
0115:  MOVF   27,W
0116:  SUBLW  03
0117:  BTFSS  03.0
0118:  GOTO   121
....................    { 
....................       lcd_envia_nibble(3); 
0119:  MOVLW  03
011A:  MOVWF  33
011B:  CALL   0B1
....................       delay_ms(5); 
011C:  MOVLW  05
011D:  MOVWF  2C
011E:  CALL   09C
....................    } 
011F:  INCF   27,F
0120:  GOTO   115
....................    lcd_envia_nibble(2); 
0121:  MOVLW  02
0122:  MOVWF  33
0123:  CALL   0B1
....................    // envia string de inicialização do display 
....................    for(conta=0;conta<=3;++conta) lcd_envia_byte(0,INI_LCD[conta]); 
0124:  CLRF   27
0125:  MOVF   27,W
0126:  SUBLW  03
0127:  BTFSS  03.0
0128:  GOTO   132
0129:  MOVF   27,W
012A:  CALL   043
012B:  MOVWF  28
012C:  CLRF   30
012D:  MOVF   28,W
012E:  MOVWF  31
012F:  CALL   0D8
0130:  INCF   27,F
0131:  GOTO   125
.................... } 
0132:  BCF    0A.3
0133:  BCF    0A.4
0134:  GOTO   2B9 (RETURN)
....................  
.................... void lcd_pos_xy( byte x, byte y) 
.................... { 
....................    byte endereco; 
....................    if(y!=1) 
0135:  DECFSZ 2D,W
0136:  GOTO   138
0137:  GOTO   13B
....................       endereco = lcd_seg_lin; 
0138:  MOVLW  40
0139:  MOVWF  2E
....................    else 
013A:  GOTO   13C
....................       endereco = 0; 
013B:  CLRF   2E
....................    endereco += x-1; 
013C:  MOVLW  01
013D:  SUBWF  2C,W
013E:  ADDWF  2E,F
....................    lcd_envia_byte(0,0x80|endereco); 
013F:  MOVF   2E,W
0140:  IORLW  80
0141:  MOVWF  2F
0142:  CLRF   30
0143:  MOVF   2F,W
0144:  MOVWF  31
0145:  CALL   0D8
.................... } 
0146:  RETURN
....................  
.................... void lcd_escreve( char c) 
.................... // envia caractere para o display 
.................... { 
....................    switch (c) 
....................    { 
0147:  MOVF   2B,W
0148:  XORLW  0C
0149:  BTFSC  03.2
014A:  GOTO   155
014B:  XORLW  06
014C:  BTFSC  03.2
014D:  GOTO   15D
014E:  XORLW  07
014F:  BTFSC  03.2
0150:  GOTO   15D
0151:  XORLW  05
0152:  BTFSC  03.2
0153:  GOTO   163
0154:  GOTO   168
....................      case '\f'    :   lcd_envia_byte(0,1); 
0155:  CLRF   30
0156:  MOVLW  01
0157:  MOVWF  31
0158:  CALL   0D8
....................               delay_ms(2); 
0159:  MOVLW  02
015A:  MOVWF  2C
015B:  CALL   09C
....................             break; 
015C:  GOTO   16E
....................      case '\n'   : 
....................      case '\r'    :   lcd_pos_xy(1,2); 
015D:  MOVLW  01
015E:  MOVWF  2C
015F:  MOVLW  02
0160:  MOVWF  2D
0161:  CALL   135
....................               break; 
0162:  GOTO   16E
....................      case '\b'    :   lcd_envia_byte(0,0x10); 
0163:  CLRF   30
0164:  MOVLW  10
0165:  MOVWF  31
0166:  CALL   0D8
....................               break; 
0167:  GOTO   16E
....................      default   :   lcd_envia_byte(1,c); 
0168:  MOVLW  01
0169:  MOVWF  30
016A:  MOVF   2B,W
016B:  MOVWF  31
016C:  CALL   0D8
....................               break; 
016D:  GOTO   16E
....................    } 
.................... } 
016E:  RETURN
....................  
....................  
.................... /* FUNÇÃO DESABILITADA DEVIDO AO DESUSO 
....................  
.................... char lcd_le( byte x, byte y) 
.................... // le caractere do display 
.................... { 
....................    char valor; 
....................    // seleciona a posição do caractere 
....................    lcd_pos_xy(x,y); 
....................    // ativa rs 
....................    output_high(lcd_rs); 
....................    // lê o caractere 
....................    valor = lcd_le_byte(); 
....................    // desativa rs 
....................    output_low(lcd_rs); 
....................    // retorna o valor do caractere 
....................    return valor; 
.................... } 
.................... */ 
....................  
....................  
.................... //**************************************************************************** 
.................... //                       Rotinas da interrupcao 
.................... //**************************************************************************** 
.................... //#inline                     //descomentar se for usar o in_line 
.................... recebe_dado_usart(){ 
....................    if (usart_rx()==novo_dado){  //Novo dado recebido 
*
002A:  DECFSZ 78,W
002B:  GOTO   02E
....................    dado_recebido=true; 
002C:  BSF    24.0
....................    } 
....................    else{ 
002D:  GOTO   03C
....................    //Se for erro reseta a USART 
....................    usart_config(modo8bits, assincrono, tx_on, usart_off, rx_continuo); 
002E:  CLRF   34
002F:  CLRF   35
0030:  MOVLW  01
0031:  MOVWF  36
0032:  CLRF   37
0033:  MOVWF  38
0034:  CALL   04B
....................    usart_config(modo8bits, assincrono, tx_on, usart_on, rx_continuo); 
0035:  CLRF   34
0036:  CLRF   35
0037:  MOVLW  01
0038:  MOVWF  36
0039:  MOVWF  37
003A:  MOVWF  38
003B:  CALL   04B
....................    } 
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... //                           INTERRUPÇÕES 
.................... //**************************************************************************** 
.................... #int_global 
.................... void interrupcao(){ 
.................... restart_wdt(); 
*
0004:  CLRWDT
.................... disable_interrupts(global); 
0005:  BCF    0B.6
0006:  BCF    0B.7
0007:  BTFSC  0B.7
0008:  GOTO   006
.................... #asm 
.................... movwf w_temp 
0009:  MOVWF  22
.................... swapf status,w 
000A:  SWAPF  03,W
.................... movwf status_temp 
000B:  MOVWF  23
.................... #endasm 
....................        
....................    if (interrupt_rx_usart()==true){  //Foi interrupão da USART? 
*
0010:  DECFSZ 78,W
0011:  GOTO   03C
....................    recebe_dado_usart(); 
....................    } 
....................  
.................... //*************************************************************************** 
.................... //                          FIM DA INTERRUPCAO 
.................... //*************************************************************************** 
.................... enable_interrupts(global); 
*
003C:  MOVLW  C0
003D:  IORWF  0B,F
.................... #asm 
.................... swapf status_temp,w 
003E:  SWAPF  23,W
.................... movwf status 
003F:  MOVWF  03
.................... swapf w_temp,f 
0040:  SWAPF  22,F
.................... swapf w_temp,w 
0041:  SWAPF  22,W
0042:  RETFIE
.................... #endasm 
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... //                             Sub-rotinas 
.................... //**************************************************************************** 
.................... trata_dado_serial(){     
....................    if (dado_recebido==true){    //Recebeu um novo dado? 
*
0184:  BTFSS  24.0
0185:  GOTO   272
....................    usart_tx(usart_rx_dado);     //Devolve o dado recebido 
0186:  MOVF   26,W
0187:  MOVWF  27
....................    lcd_escreve('\f');   //Limpa o lcd 
*
018A:  MOVLW  0C
018B:  MOVWF  2B
018C:  CALL   147
....................    lcd_escreve('\b'); 
018D:  MOVLW  08
018E:  MOVWF  2B
018F:  CALL   147
....................    lcd_pos_xy(1,1); 
0190:  MOVLW  01
0191:  MOVWF  2C
0192:  MOVWF  2D
0193:  CALL   135
....................    printf(lcd_escreve, "Rx: %u", usart_rx_dado); 
0194:  MOVLW  6F
0195:  BSF    03.6
0196:  MOVWF  0D
0197:  MOVLW  00
0198:  MOVWF  0F
0199:  BCF    03.0
019A:  MOVLW  04
019B:  BCF    03.6
019C:  MOVWF  27
*
01EA:  MOVF   26,W
01EB:  MOVWF  27
01EC:  MOVLW  1B
01ED:  MOVWF  28
....................    dado_recebido=false; 
*
0221:  BCF    24.0
....................     if (usart_rx_dado==65){   //A=65 
0222:  MOVF   26,W
0223:  SUBLW  41
0224:  BTFSS  03.2
0225:  GOTO   272
....................       lcd_pos_xy(1,2); 
0226:  MOVLW  01
0227:  MOVWF  2C
0228:  MOVLW  02
0229:  MOVWF  2D
022A:  CALL   135
....................       lcd_escreve("Funfou!");       
022B:  MOVLW  73
022C:  BSF    03.6
022D:  MOVWF  0D
022E:  MOVLW  00
022F:  MOVWF  0F
....................       } 
....................     
....................    } 
.................... } 
*
0272:  BCF    0A.3
0273:  BCF    0A.4
0274:  GOTO   2C4 (RETURN)
....................  
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... //                          Rotina Principal 
.................... //**************************************************************************** 
....................  
.................... void main(){ 
0275:  CLRF   04
0276:  BCF    03.7
0277:  MOVLW  1F
0278:  ANDWF  03,F
0279:  BSF    03.5
027A:  BSF    1F.0
027B:  BSF    1F.1
027C:  BSF    1F.2
027D:  BCF    1F.3
.................... //********************** CONFIGURAÇÕES INICIAIS ***************************** 
....................       setup_timer_0(rtcc_internal); //clock interno, prescaler 1:2 
*
0281:  BSF    03.5
0282:  MOVF   01,W
0283:  ANDLW  C0
0284:  MOVWF  01
....................       setup_wdt(wdt_288ms); 
0285:  MOVLW  0C
0286:  MOVWF  77
0287:  BCF    03.5
0288:  CLRF   01
0289:  MOVLW  81
028A:  MOVWF  04
028B:  BCF    03.7
028C:  MOVF   00,W
028D:  ANDLW  F0
028E:  IORLW  07
028F:  MOVWF  00
0290:  CLRWDT
0291:  MOVF   00,W
0292:  ANDLW  F7
0293:  BTFSC  77.3
0294:  ANDLW  F0
0295:  IORWF  77,W
0296:  MOVWF  00
....................              
....................       //Configurações da USART 
....................       usart_baud_rate(high_speed, 25); 
0297:  MOVLW  01
0298:  MOVWF  27
0299:  MOVLW  19
029A:  MOVWF  28
029B:  GOTO   077
029C:  CLRF   00
029D:  BTFSC  0B.7
029E:  BSF    00.7
029F:  BCF    0B.7
....................       usart_config(modo8bits, assincrono, tx_on, usart_on, rx_continuo); 
02A0:  CLRF   34
02A1:  CLRF   35
02A2:  MOVLW  01
02A3:  MOVWF  36
02A4:  MOVWF  37
02A5:  MOVWF  38
02A6:  CALL   04B
02A7:  BTFSC  00.7
02A8:  BSF    0B.7
....................  
....................  
....................       bit_set(option_reg,7);    //sem pull-up 
02A9:  BSF    03.5
02AA:  BSF    01.7
....................  
.................... //    Configuração do tris 
.................... //    Bit porta: 76543210 
....................       tris_a = 0b00000000; 
02AB:  CLRF   05
....................       tris_b = 0b00000000; 
02AC:  CLRF   06
....................       tris_c = 0b10000000; 
02AD:  MOVLW  80
02AE:  MOVWF  07
....................       tris_d = 0b00000000; 
02AF:  CLRF   08
....................        
....................       enable_interrupts(GLOBAL); //Habilita interrupção de recepção da USART 
02B0:  MOVLW  C0
02B1:  BCF    03.5
02B2:  IORWF  0B,F
....................       usart_int(tx_int_off, rx_int_on, int_9bit_off); 
02B3:  CLRF   27
02B4:  MOVLW  01
02B5:  MOVWF  28
02B6:  CLRF   29
02B7:  GOTO   086
....................        
.................... //    Inicialização do LCD 
....................       lcd_ini(); 
02B8:  GOTO   0F8
....................       delay_ms(100); 
02B9:  MOVLW  64
02BA:  MOVWF  2C
02BB:  CALL   09C
....................       lcd_escreve('\f');   //Limpa o lcd 
02BC:  MOVLW  0C
02BD:  MOVWF  2B
02BE:  CALL   147
....................       lcd_escreve('\b'); 
02BF:  MOVLW  08
02C0:  MOVWF  2B
02C1:  CALL   147
.................... //******************** INICIALIZAÇÃO DE VARIÁVEIS *************************** 
....................        
.................... //**************************************************************************** 
.................... //                             INICIO DO LOOP 
.................... //**************************************************************************** 
....................       while(1){   
....................       restart_wdt(); 
02C2:  CLRWDT
....................       trata_dado_serial(); 
02C3:  GOTO   184
....................           
....................       } 
02C4:  GOTO   2C2
.................... //********************************* FIM ************************************** 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
02C5:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
